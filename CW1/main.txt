int main(int argc, char **argv)
{
	/*random_device rd;
	default_random_engine generator(rd());
	uniform_real_distribution<double> distribution;
	auto get_random_number = bind(distribution, generator);*/

	// *** These parameters can be manipulated in the algorithm to modify work undertaken ***
	constexpr size_t dimension = 400;
	vector<sphere> spheres
	{
		sphere(1e5, vec(1e5 + 1, 40.8, 81.6), vec(), vec(0.75, 0.25, 0.25), reflection_type::DIFFUSE),
		sphere(1e5, vec(-1e5 + 99, 40.8, 81.6), vec(), vec(0.25, 0.25, 0.75), reflection_type::DIFFUSE),
		sphere(1e5, vec(50, 40.8, 1e5), vec(), vec(0.75, 0.75, 0.75), reflection_type::DIFFUSE),
		sphere(1e5, vec(50, 40.8, -1e5 + 170), vec(), vec(), reflection_type::DIFFUSE),
		sphere(1e5, vec(50, 1e5, 81.6), vec(), vec(0.75, 0.75, 0.75), reflection_type::DIFFUSE),
		sphere(1e5, vec(50, -1e5 + 81.6, 81.6), vec(), vec(0.75, 0.75, 0.75), reflection_type::DIFFUSE),
		sphere(16.5, vec(27, 16.5, 47), vec(), vec(1, 1, 1) * 0.999, reflection_type::SPECULAR),
		sphere(16.5, vec(73, 16.5, 78), vec(), vec(1, 1, 1) * 0.999, reflection_type::REFRACTIVE),
		sphere(600, vec(50, 681.6 - 0.27, 81.6), vec(12, 12, 12), vec(), reflection_type::DIFFUSE)
	};
	// **************************************************************************************

	ray camera(vec(50, 52, 295.6), vec(0, -0.042612, -1).normal());
	vec cx = vec(0.5135);
	vec cy = (cx.cross(camera.direction)).normal() * 0.5135;
	vec r;
	vector<vec> pixels(dimension * dimension);


	//R//Create results file
	ofstream results("test.csv", ofstream::out);
	results << "Image Dimensions (px)" << "," << "Samples per Pixel" << "," << "Time taken (ms)" << endl;


	//constexpr 
	size_t samples = 1; // Algorithm performs 4 * samples per pixel.

						//This loops through the functions from the start value of samples up here to 1024 * 4 = 4096
						//It will then stop at 256 * 4 = 1024.
						//This way you can set start as 1 and the loop as samples != 4. This will perform only one loop.
						//you can use this to have only one iteration. If you set samples = 16 and while (samples != 64) it will only perform
						// 16 * 4 = 64;
						//samples increases at the end of the loop like "samples *= 4", so the loop will stop or it will keep going
						//while (samples != 64)
						//{

						//R//Get Start Time
						//auto start = chrono::system_clock::now();



						/*for (size_t y = 0; y < dimension; ++y)
						{
						cout << "Rendering " << dimension << " * " << dimension << "pixels. Samples:" << samples * 4 << " spp (" << 100.0 * y / (dimension - 1) << ")" << endl;
						for (size_t x = 0; x < dimension; ++x)
						{
						for (size_t sy = 0, i = (dimension - y - 1) * dimension + x; sy < 2; ++sy)
						{
						for (size_t sx = 0; sx < 2; ++sx)
						{
						r = vec();
						for (size_t s = 0; s < samples; ++s)
						{
						double r1 = 2 * get_random_number(), dx = r1 < 1 ? sqrt(r1) - 1 : 1 - sqrt(2 - r1);
						double r2 = 2 * get_random_number(), dy = r2 < 1 ? sqrt(r2) - 1 : 1 - sqrt(2 - r2);
						vec direction = cx * static_cast<double>(((sx + 0.5 + dx) / 2 + x) / dimension - 0.5) + cy * static_cast<double>(((sy + 0.5 + dy) / 2 + y) / dimension - 0.5) + camera.direction;
						r = r + radiance(spheres, ray(camera.origin + direction * 140, direction.normal()), 0) * (1.0 / samples);
						}
						pixels[i] = pixels[i] + vec(clamp(r.x, 0.0, 1.0), clamp(r.y, 0.0, 1.0), clamp(r.z, 0.0, 1.0)) * 0.25;
						}
						}
						}
						}*/


						//R//Call pixelsI
						//Not right yet - needs to be threaded and shit
						//pixelsI(dimension, samples, r, cx, cy, spheres, pixels);


						//R//
	auto threadCount = thread::hardware_concurrency();
	vector<thread> threads;

	//R//Get Start Time
	auto start = chrono::system_clock::now();

	for (int i = 0; i < threadCount; i++)
	{
		threads.push_back(thread(pixelsI, dimension, samples, r, cx, cy, camera, spheres, std::ref(pixels)));
		//threads.push_back(thread(pixelsI, dimension, samples, r, cx, cy, spheres, std::ref(pixels)));
	}

	for (auto &t : threads)
	{
		t.join();
	}

	//R//Get end time and calculate the time taken
	auto end = chrono::system_clock::now();
	auto total = chrono::duration_cast<chrono::milliseconds>(end - start).count();

	//R//Output results
	results << dimension << " * " << dimension << ", " << samples * 4 << "," << total << endl;
	//samples *= 4;

	//}


	//Create the image file
	cout << "img.bmp" << (array2bmp("img.bmp", pixels, dimension, dimension) ? " Saved\n" : " Save Failed\n");

	return 0;
}